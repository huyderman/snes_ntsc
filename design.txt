snes_ntsc Design Notes
----------------------
These mostly deal with how I kept things optimal.


Interface
---------
The caller is required to allocate memory for the tables. This eliminates the
need for any error return values from the library, and allows the caller to
choose how the memory is allocated. One thing that might help speed is to align
it to a 256-byte boundary to help with cache alignment.

The init/setup function parameters are all adjusted so that 0 gives a normal
picture, -1 the lowest value, and 1 the highest. This is different than the
usual ranges for some of the parameters, like contrast and saturation being 1.0
for a normal picture or the hue control being expressed in radians. Using 0 for
the default is convenient, allows consistent mapping to user-interface
elements, and allows the library to decide the upper bounds internally, rather
than having the caller know about them (i.e. internally sharpness working
poorly above 2.5, internally contrast above 1.5, etc.).


Initialization
--------------
There are a large number of table entries to initialize, so this code must be
fairly fast. About half the time is spent doing NTSC signal processing on
pixels in ntsc_to_rgb, so the this code is optimized for an input signal that
only has four non-zero points. This allows the convolution to be very
optimized.

Floating-point math is done in with "float" rather than "double" since extra
precision isn't needed. Rewriting the ntsc_to_rgb to use fixed-point math might
give a significant speedup, but I'm not ready to take that on yet.


Kernels
-------
Each source SNES pixel contributes 16 pixels to the output image, spread to the
left and right sides of its center. This is due to the way an NTSC composite
video signal is decoded in a television (actually, in a TV the spread is
asymmetrical, with more on the right). This contribution is stored in a
"kernel", a 16-pixel array (named due to the similar function of a filter's
convolution kernel).

The appearance of a pixel of a given color on screen depends on three things:
its RGB value, its column on screen modulo 3, and the scanline's burst phase (3
possible phases). This yields 9 possible appearances for a given RGB value; for
each possible color, a table is kept of these 9 kernels.

Each pixel in a kernel can add *and* subtract from the RGB levels of the output
pixel, so the components need to be signed. They are stored with 10 bits each
in a 32-bit integer, in a way that allows regular addition to add each
component independently. For example, a pixel with r = 0x52, g = -0x21, b =
0x01 is stored as (r << 20) + (g << 10) + b, which comes out to 0x051F7C01.
Note how the 0x52 of the red became 0x51, due to the negative green component.

The original values can be recovered by adding a bias to convert them to
offset-binary, extracting them by masking, then subtracting the bias again.
0x051F7C01 + (0x200 << 20) + (0x200 << 10) + 0x200 = 0x25277E01. The red
component at the top is now unaffected by green. The bias only needs to be
added once to the sum of several pixels from kernels. Rather than adding it
explicitly in the blitter loop, it is added to the entries for the first half
of the kernels for pixels at column alignment 0. This results in the equivalent
behavior at run-time.

Once the pixels from each kernel are added, the components need to be clamped
to the 0 to 0x7F or 0 to 0xFF range, depending on whether low-res or high-res
is being used; high-res will be covered here, with its 0xFF maximum range. When
converted to offset binary, they cover the range 0 to 0x3FF, corresponding to
the equivalent signed range of -0x200 to 0x1FF. The range 0 to 0xFF maps to
0x200 to 0x2FF. The high two bits tell us whether an overflow occurred: 0x3XX
means positive overflow, 0x2XX means no overflow, and 0x1XX or 0x0XX means
negative overflow. These can be used to generate values to AND and OR with to
either set all bits (on positive overflow) or clear all bits (on negative
overflow).

The masks can be generated simultaneously for each component, making it a very
efficient operation. First, the OR mask is created by subtracting the top two
bits shifted down from 0x202. 0x202 - 3 = 0x1FF, 0x202 - 2 = 0x200. The low
bits then form an OR mask of 0xFF for positive overflow, and 0x00 for in-range.
The value for negative doesn't matter since the AND mask must be 0. The OR mask
has the top two shifted bits subtracted again to form the AND mask. 0x202 - 3 -
3 = 0x1FC, 0x202 - 2 - 2 = 0x1FE, 0x201 - 1 - 1 = 0x200, 0x202 - 0 - 0 = 0x202.
The low two bits aren't always correct, but those don't matter since only the
upper 5 bits are used for output. CLAMP_RGB implements this.

Low-res and high-res modes share the same kernels. In high-res mode, odd pixels
are shifted half a SNES pixel width to the right. The kernels for this turn out
to be the same as for the even pixels, allowing sharing. The only issue is the
doubling of the brightness when adding twice as many pixels for each output
pixel. To handle this, the kernels are generated at half the normal level and
effectively doubled in the low-res blitter and left unchanged in the high-res
blitter. There is still enough accuracy to leave the picture quality unaffected
in any significant way.

It is important that a run of the same colored SNES pixels results in a solid
color on screen, without any speckles of slightly different color. Values are
rounded to limited precision to build the kernels, so it's possible that the
totals will vary from pixel to pixel. Since output is in 16-bit RGB color, with
its quite limited precision for each color component, this error is amplified
to an unacceptable level. These errors are corrected by adding the kernels for
the three column alignments for a single color as they would be in the blitter
on a long run of the same color, comparing the sums with the expected color
values, then adjusting the entries for one of the kernels based on the error.
The errors are never more than a couple of units, so the effect on the modified
kernel's pixel appearance is minimal.


Blitter
-------
The blitters are broken into two functions rather than one large function with
a boolean parameter to select between high-res and low-res. This is to avoid
stressing the compiler's optimizer. Unfortunately it makes the interface a bit
less practical.

Pixel calculation is unrolled to the length of a kernel to avoid having to
shuffle pointers. Pointers to kernels for each of the active pixels are kept in
individual local variables rather than an array because some compilers don't
put array members in registers. The PIXEL macro takes the index of the pixel as
a compile-time constant which allows conditionals that resolve at compile-time.
This simplifies code without any performance impact.

A modern RISC processor with 16 or 32 general-purpose registers will do well
for these functions, being able to keep most everything in registers.
Unfortunately, on a legacy architecture like the IA-32 that is simply not
possible. The kernel pointers are only modified each time a new pixel begins
for that offset (every 16 output pixels), so the impact of a lack of registers
is reduced.

Pixels are written in pairs in a 32-bit integer to halve the number of writes,
which might help when outputting directly to video memory. This unfortunately
makes the code dependent on knowing the byte order of the processor.


Memory Utilization
------------------
The use of memory for the kernel table was a central issue. At first it used 16
MB just for low-res support. By reducing the number of colors available, the
table size was reduced to 1/4 that. The visual change is quite minor. Complex
color reduction algorithms were experimented with, which converted to a YIQ
color space and used varying resolutions for the luminance, saturation, and
hue, but these didn't yield good results. The dead-simple approach of simply
clearing the low bits of the RGB components was tried, with good results.
Clearing the low bits of the red and blue components, reducing them to 4 bits
of precision, had very little visible effect. Most games won't be using shades
very close together, due to the limited size of SNES palettes.

A typical image will use a small number of colors scattered throughout the
color space. For any given color, it will probably be used at each of the three
column alignments and on each of the three phases (9 combined possibilities),
so the kernels for each color are kept together to reduce the number of cache
lines kept resident. Each group of kernels for a color total 576 bytes of
memory, which is a multiple of 64. Cache lines are sometimes 32 bytes for the
L1 cache, and 128 bytes for the L2 cache, so this will further reduce the
number of lines used since kernels won't cross cache line boundaries.

